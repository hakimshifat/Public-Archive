# Advanced CTF Reversing & Exploitation Techniques (2018–2023)

## A. Technique Cheat-Sheet

- **Control-Flow Obfuscation & CFG Reconstruction:** Many reverse-engineering challenges hide logic behind opaque predicates and flattened control flow. Solvers often remove or ignore always-false branches (opaque predicates) and rebuild a clean control-flow graph. For example, O-LLVM obfuscation inserts bogus branches and opaque conditions[hxp.io](https://hxp.io/blog/74/0CTF-2020-writeups/#:~:text=To%20worsen%20things%2C%20the%20authors,manual%20procedure%20during%20the%20second); teams solved this by identifying unreachable code (e.g. self-invalidating jumps) and patching or nopping them out[medium.com](https://medium.com/the-bkpt/plaidctf-2020-reee-80c5cc21ccb1#:~:text=2,with%20opaque%20predicates%20like). In one case (“J” – 0CTF/TCTF 2020), nearly all conditional jumps were replaced with `int3` breakpoints handled by a custom exception handler (“nanomites”)[hxp.io](https://hxp.io/blog/74/0CTF-2020-writeups/#:~:text=), forcing solvers to parse a hidden jump table and hook the exception dispatcher to reconstruct real control flow.
    
- **Deobfuscation Tricks (Dynamic vs Static Analysis):** Challengers mix static and dynamic methods to unravel obfuscation. A common approach is dumping self-modifying or encrypted code at runtime and then disassembling it. In PlaidCTF 2020’s _reee_ challenge, the flag-checking function was decrypted in memory on the fly. Solvers used GDB watchpoints to catch when input was accessed, dumped the decoded bytes with GDB, and then analyzed them in IDA/Ghidra[medium.com](https://medium.com/the-bkpt/plaidctf-2020-reee-80c5cc21ccb1#:~:text=At%20this%20point%2C%20we%20ran,that%20is%20decrypted%20at%20runtime)[medium.com](https://medium.com/the-bkpt/plaidctf-2020-reee-80c5cc21ccb1#:~:text=We%20ran%20the%20program%20under,dumped%20the%20decrypted%20function%20with). The dumped code contained anti-disassembly tricks like a jump that targeted the middle of itself and arithmetic-based opaque jumps; these were patched or ignored. Notably, Ghidra’s analyzer automatically pruned some unreachable bogus code, aiding decompilation[medium.com](https://medium.com/the-bkpt/plaidctf-2020-reee-80c5cc21ccb1#:~:text=In%20this%20case%2C%20the%20,IDA%20anything%20in%20these%20cases). Tools like dynamic instrumentation (Intel PIN, Frida) or emulators can also execute and dump hidden logic.
    
- **Hybrid Symbolic Execution & Concolic Analysis:** When pure static or manual reversing is tedious, solvers turn to symbolic execution frameworks like **angr**. Moderately complex crackmes with many branches can be solved by formulating the problem for an SMT solver. For instance, in Google CTF 2023’s _oldschool_ challenge, instead of fully reversing a retro text-based password checker, solvers used angr’s **Symbion** (which integrates angr with a live GDB session)[ctftime.org](https://ctftime.org/writeup/37461#:~:text=make%20use%20of%20,angr). They concretely ran the program up to a certain point (handling its ncurses UI in real time) and then injected symbolic variables for the password. By syncing the program state from GDB to angr at a strategic checkpoint, they let angr explore paths leading to the “success” branch[ctftime.org](https://ctftime.org/writeup/37461#:~:text=Concolic%20Execution)[ctftime.org](https://ctftime.org/writeup/37461#:~:text=,angr). This hybrid approach (concolic execution) leveraged dynamic execution to handle setup/state and symbolic solving for the core logic, dramatically reducing manual work.
    
- **Custom Architecture Emulation:** Some reversing tasks present binaries for uncommon or custom architectures (including VM-based protections). Tackling these often involves finding or writing an emulator or IDA/Ghidra loader. In 0CTF 2022, a challenge provided a raw **Vectrex console** ROM (Motorola 6809 CPU) with an unknown entry point[mahaloz.re](https://mahaloz.re/2022/09/23/0ctf22-rev.html#:~:text=The%20Vectrex%20Console). Solvers first identified the file format (via the `file` command), then located an open-source Vectrex emulator. By stepping through the ROM in the emulator’s debugger, they found the code entry point and observed runtime behavior[mahaloz.re](https://mahaloz.re/2022/09/23/0ctf22-rev.html#:~:text=During%20this%20scouting%20phase%20of,noobs%20approached%20the%20same%20problem). They also wrote a custom Ghidra loader script (or manually marked code sections in IDA) to disassemble the 6809 machine code[mahaloz.re](https://mahaloz.re/2022/09/23/0ctf22-rev.html#:~:text=With%20that%20squared%20away%2C%20we,his%20own%20loader%20for%20Ghidra). The general techniques include consulting technical docs or Wiki for the architecture, using existing emulators or writing one (e.g. Unicorn/Unicorn-engine or QEMU), and possibly instrumenting the emulator to log or modify state. This approach converts an unfamiliar-ISA problem into a more standard reverse-engineering workflow by leveraging tools from the target’s ecosystem.
    
- **Heap Feng Shui & Grooming:** Exploit challenges heavily rely on shaping the heap layout to achieve desired overlaps or leaks. **Heap feng shui**, as it’s called, is the art of “precisely aligning” heap allocations to manipulate memory layout[en.wikipedia.org](https://en.wikipedia.org/wiki/Heap_feng_shui#:~:text=In%20computer%20security%20%2C%20heap,of%20precise%20alignments%20in%20space). Practically, this means making allocations of carefully chosen sizes and frees in specific orders to place key objects adjacent in memory or to land controlled data at a target address. For example, a challenge might require arranging two chunks such that after a free, one chunk’s metadata overlaps with another object. A common pattern is to allocate two large chunks, free one to push it into the unsorted bin, then allocate smaller chunks to prevent consolidation – this isolates a libc pointer in the freed large chunk which can be read as a leak (used in many libc leak exploits)[ctftime.org](https://ctftime.org/writeup/31843#:~:text=Since%20we%20are%20able%20to,of%20a%20unsort%20bin%20chunk)[ctftime.org](https://ctftime.org/writeup/31843#:~:text=,0x10uLL%29%3B). Another pattern is **tcache poisoning**: writing a fake forward pointer into a freed tcache chunk to force `malloc` to return an arbitrary address. In **idekCTF 2021 – Coffee Shop**, a use-after-free allowed exactly this: the solver freed a “complaint” chunk and edited its `next` pointer to the global function pointer, so that a later `malloc` would return that address, letting them overwrite the function pointer[ctftime.org](https://ctftime.org/writeup/31843#:~:text=,arbitrary%20writes%20and%20thus%20RCE)[ctftime.org](https://ctftime.org/writeup/31843#:~:text=,). (They ultimately achieved RCE by pointing the function pointer to `system` and triggering it). Heap grooming is often facilitated by utilities like **Pwntools** (for scripting allocation sequences) and by understanding allocator internals (fastbins, tcache bins, unsorted bin behavior, etc.).
    
- **Global Offset Table & Function Pointer Hijacking:** Overwriting code pointers remains a staple technique, whether it’s a GOT entry, a vtable, or a saved return address. Many CTF “pwn” tasks involve partial or full overwrites to redirect execution flow. For example, in a classic format-string exploit, one might overwrite the GOT entry of `exit()` to point to `system()`. In modern heap challenges with C++ binaries, a favorite trick is vtable smashing: e.g., in _heapme_ (FIC 2020 Prequals), a heap overflow allowed overwriting a C++ object’s vtable pointer[synacktiv.com](https://www.synacktiv.com/en/publications/fic2020-prequals-ctf-write-up#:~:text=typedef%20struct%20vtable%20,write%29%28Disk%20this%29%3B%20%7D%20vtable). By pointing it to a fake vtable (sprayed in memory) where the `write` method pointer was replaced with `system`, the next virtual function call effectively jumped to `system("/bin/sh")`. Since PIE was enabled, the team first had to leak libc or binary base via an unsorted-bin or tcache leak[synacktiv.com](https://www.synacktiv.com/en/publications/fic2020-prequals-ctf-write-up#:~:text=As%20we%20have%20a%20full,data%20part%20of%20the%20disk), then compute target addresses for the overwrite. The general idea is to hijack an indirect call: _GOT hijacking_ (overwriting a GOT entry when RELRO is partial) or _function pointer overwrites_ (in .bss or on heap) to get control. As defenses hardened, direct GOT writes became less common, but one still sees them in easier challenges or via format-string vulnerabilities. Modern write-ups often show use of **Pwntools** for such tasks (e.g., to find the offset of a GOT entry and craft the payload), and use GDB/GEF to verify the pointer overwrite.
    
- **Ret2dlresolve (Dynamic Linker Trick):** A clever ROP technique to call any library function without an explicit pointer, used when you can’t directly call `system` (e.g., no libc leak yet, or no `system` in GOT). The idea is to forge a fake ELF symbol resolution on the stack and invoke the dynamic loader’s resolver. For instance, _DiceCTF 2021 – babyrop_ explicitly expected either ret2csu or ret2dlresolve. With a tiny binary that had only `write` and `gets` in the PLT, the solver chose **ret2dlresolve** to call `system("/bin/sh")` without knowing libc base[danielepusceddu.github.io](https://danielepusceddu.github.io/ctf_writeups/dice21_babyrop/#:~:text=This%20technique%20is%20extremely%20powerful,entry%20in%20the%20.plt). They set up a fake `.plt` and `.dynsym` entry on the stack for “system” and then called the linker routine `__libc_start_main@plt` (or appropriate resolver stub) to resolve that symbol, effectively tricking the loader into calling system in the process[danielepusceddu.github.io](https://danielepusceddu.github.io/ctf_writeups/dice21_babyrop/#:~:text=This%20technique%20is%20extremely%20powerful,entry%20in%20the%20.plt)[danielepusceddu.github.io](https://danielepusceddu.github.io/ctf_writeups/dice21_babyrop/#:~:text=,html). This technique requires writing structured data to the stack (or another writable segment) and knowing or brute-forcing some offsets, but **Pwntools** simplifies it greatly – it has a built-in `Ret2dlresolvePayload` that can generate the necessary bytes[danielepusceddu.github.io](https://danielepusceddu.github.io/ctf_writeups/dice21_babyrop/#:~:text=this%20technique%20without%20a%20ROP). Ret2dlresolve is a valuable technique in CTFs to bypass scenarios where a leak is hard or when only limited libc functions are available; write-ups often reference the original paper or blog posts detailing its mechanics.
    
- **Seccomp Bypass & Sandbox Escapes:** Many recent pwn challenges incorporate **seccomp** (secure computing mode) filters to restrict syscalls, forcing players to get creative. Bypassing seccomp can range from simple (use allowed syscalls to achieve the goal) to very advanced (exploit a bug in the filter or use kernel features). One recurring simple bypass is using alternate syscall interfaces – e.g., if `execve` is blocked but the 32-bit _x32 ABI_ syscall entry is not filtered, one can invoke the 32-bit `execve` which the kernel will still execute[n132.github.io](https://n132.github.io/2022/07/03/Guide-of-Seccomp-in-CTF.html#:~:text=If%20the%20filter%20doesn%E2%80%99t%20check,ABI%20to%20bypass%20the%20filter). More complex scenarios involve seccomp **USER_NOTIF** trickery: _Google CTF 2022 – “S2”_ provided only `fork`, `clone`, `seccomp` and `ioctl` syscalls, none of the usual file or exec calls[n132.github.io](https://n132.github.io/2022/07/04/S2.html#:~:text=In%20the%20main%20function%2C%20the,a%20hint%20of%20the%20challenge). The trick was to use `seccomp(SECCOMP_SET_MODE_FILTER, …, filter, SECCOMP_FILTER_FLAG_NEW_LISTENER)` to install a _user-space seccomp monitor_ and obtain a file descriptor, then use an `ioctl` on that fd to effectively approve all syscalls[n132.github.io](https://n132.github.io/2022/07/04/S2.html#:~:text=1,fd%29%20to%20allow%20all%20syscalls)[n132.github.io](https://n132.github.io/2022/07/04/S2.html#:~:text=,being%20traced%20by%20the%20monitor). This leveraged the fact that seccomp user-space notification has higher priority than the kernel’s default tracer (the “sandbox2” monitor), letting the exploit bypass the intended sandbox entirely. In kernel-pwn challenges, seccomp bypass might not be the main goal but can appear as a layer (e.g., solving a kernel challenge might involve disabling seccomp from kernel space after gaining write primitives). Tools like `seccomp-tools` (for analyzing BPF filters) and `strace` (to see which calls are blocked) are helpful. There are excellent guides enumerating bypass techniques for different seccomp filter types[n132.github.io](https://n132.github.io/2022/07/03/Guide-of-Seccomp-in-CTF.html#:~:text=forbid%20,of%20them%20in%20this%20passage)[n132.github.io](https://n132.github.io/2022/07/03/Guide-of-Seccomp-in-CTF.html#:~:text=This%20passage%20would%20focus%20on,one%20challenge%20for%20every%20type) – from using alternate architectures to exploiting logic flaws in custom filters.
    
- **Kernel Exploitation Primitives:** CTFs have increasingly featured kernel challenges (Linux kernel, and sometimes others). Key primitives to obtain in kernel pwn are **arbitrary read/write** in kernel memory and execution control, often leading to privilege escalation (getting root). Typical starting bugs include heap out-of-bounds or use-after-free in kernel modules or drivers. For example, a challenge may allow a UAF on a `tty_struct` (terminal device) – the solver frees it and then reuses the dangling pointer to overwrite its function pointer table (vtable). In _3kCTF 2021 – klibrary_, a UAF in a character device allowed overwriting a `tty_struct->ops` pointer, and the team pointed it to a fake table such that a method call invoked `commit_creds(prepare_kernel_cred(0))` or wrote to the `modprobe_path` global[github.com](https://github.com/smallkirby/kernelpwn#:~:text=), instantly elevating privileges (modprobe_path is a common target: writing “/bin/sh” to it and then triggering an invalid exec causes the kernel to execute a root shell). Kernel exploits must also bypass defenses like KASLR (needing an info leak or known static addresses), SMEP/SMAP (needing ROP or data-only attacks to avoid userland code execution), etc. Write-ups often enumerate which mitigations were active[github.com](https://github.com/smallkirby/kernelpwn#:~:text=,80) and explain how they were circumvented – e.g. using a kernel ROP chain (ret2dir on kernel text) or disabling SMEP by flipping a bit in CR4 register if a write primitive is gained. Tools like **volatility** or custom GDB + QEMU setups help in analyzing kernel memory, and using existing kernel gadgets (from vDSO or Perf events) is common. Many kernel CTF write-ups also highlight the use of the **userfaultfd (uffd)** technique to exploit race conditions or delay kernel threads, as well as spraying techniques (using `msg_msg` IPC objects, or in one case using the `user_key_payload` infrastructure)[github.com](https://github.com/smallkirby/kernelpwn#:~:text=,80)[github.com](https://github.com/smallkirby/kernelpwn#:~:text=,nightclub%20from%20pbctf%202021) to shape kernel heap layout analogous to userland heap feng shui. In summary, kernel pwn requires chaining a vulnerability to first get read/write (e.g., by overlapping objects or reusing freed objects) and then leveraging that to execute privileged operations – a mastery of kernel internals and careful use of primitives.
    

## B. Challenge Index

Below is an index of notable CTF challenges from the past 5 years, illustrating these techniques:

|**Challenge (Category)**|**Event (Year)**|**Key Technique**|**Write-up / Reference**|
|---|---|---|---|
|**“J” (Reversing)** – Windows crypto/obfuscation|0CTF/TCTF Quals (2020)|Heavy OLLVM obfuscation (opaque predicates, bogus control flow) plus “nanomites” (int3-breakpoint based control flow); required hooking exception handler and reversing custom XTEA-like crypto[hxp.io](https://hxp.io/blog/74/0CTF-2020-writeups/#:~:text=To%20worsen%20things%2C%20the%20authors,manual%20procedure%20during%20the%20second)[hxp.io](https://hxp.io/blog/74/0CTF-2020-writeups/#:~:text=).|hxp team write-up[hxp.io](https://hxp.io/blog/74/0CTF-2020-writeups/#:~:text=To%20worsen%20things%2C%20the%20authors,manual%20procedure%20during%20the%20second)[hxp.io](https://hxp.io/blog/74/0CTF-2020-writeups/#:~:text=)|
|**reee (Reversing)** – crackme|PlaidCTF (2020)|Self-modifying code decrypted at runtime; anti-disassembly tricks (jump-into-self, opaque jns never taken) and simple VM loop. Solved via dumping decrypted code in GDB and patching opaque predicates[medium.com](https://medium.com/the-bkpt/plaidctf-2020-reee-80c5cc21ccb1#:~:text=2,with%20opaque%20predicates%20like)[medium.com](https://medium.com/the-bkpt/plaidctf-2020-reee-80c5cc21ccb1#:~:text=Interestingly%2C%20Ghidra%E2%80%99s%20decompiler%20dealt%20far,code%20without%20any%20manual%20fixups).|BKP write-up (Medium)[medium.com](https://medium.com/the-bkpt/plaidctf-2020-reee-80c5cc21ccb1#:~:text=2,with%20opaque%20predicates%20like)[medium.com](https://medium.com/the-bkpt/plaidctf-2020-reee-80c5cc21ccb1#:~:text=Interestingly%2C%20Ghidra%E2%80%99s%20decompiler%20dealt%20far,code%20without%20any%20manual%20fixups)|
|**Vectrex ROM (Reversing)** – “back to the 90s”|0CTF Finals (2022)|Unknown architecture (Motorola 6809) binary. Used an open-source Vectrex emulator + custom Ghidra loader. Identified entry point and game logic via emulator, then statically reversed the password check[mahaloz.re](https://mahaloz.re/2022/09/23/0ctf22-rev.html#:~:text=The%20Vectrex%20Console)[mahaloz.re](https://mahaloz.re/2022/09/23/0ctf22-rev.html#:~:text=During%20this%20scouting%20phase%20of,noobs%20approached%20the%20same%20problem).|Mahaloz blog[mahaloz.re](https://mahaloz.re/2022/09/23/0ctf22-rev.html#:~:text=The%20Vectrex%20Console)[mahaloz.re](https://mahaloz.re/2022/09/23/0ctf22-rev.html#:~:text=During%20this%20scouting%20phase%20of,noobs%20approached%20the%20same%20problem)|
|**oldschool (Reversing)** – retro UI crackme|Google CTF Finals (2023)|Concolic execution with angr+Symbion. Attached angr to a live process (ncurses program) using avatar², injected symbolic input at a late stage, and solved for the password automatically[ctftime.org](https://ctftime.org/writeup/37461#:~:text=So%20our%20main%20way%20of,angr)[ctftime.org](https://ctftime.org/writeup/37461#:~:text=,angr).|ALLES team write-up[ctftime.org](https://ctftime.org/writeup/37461#:~:text=So%20our%20main%20way%20of,angr)[ctftime.org](https://ctftime.org/writeup/37461#:~:text=,angr)|
|**babyrop (Pwn)** – x64 binary|DiceCTF (2021)|ret2dlresolve technique to call `system` without libc leak. Crafted fake ELF structures on stack and invoked dynamic linker resolver[danielepusceddu.github.io](https://danielepusceddu.github.io/ctf_writeups/dice21_babyrop/#:~:text=This%20technique%20is%20extremely%20powerful,entry%20in%20the%20.plt). Also demonstrated ret2csu for setting up ROP arguments.|Daniele Pusceddu’s blog[danielepusceddu.github.io](https://danielepusceddu.github.io/ctf_writeups/dice21_babyrop/#:~:text=This%20technique%20is%20extremely%20powerful,entry%20in%20the%20.plt)[danielepusceddu.github.io](https://danielepusceddu.github.io/ctf_writeups/dice21_babyrop/#:~:text=,html)|
|**Coffee Shop (Pwn)** – heap UAF|idekCTF (2021)|Use-after-free on heap with tcache. Performed heap feng shui to leak libc (unsorted bin chunk) and then exploited a stale function pointer (“manager” struct) by reallocating that chunk. Overwrote the function pointer to `system` and triggered it[ctftime.org](https://ctftime.org/writeup/31843#:~:text=Since%20we%20are%20able%20to,of%20a%20unsort%20bin%20chunk)[ctftime.org](https://ctftime.org/writeup/31843#:~:text=,).|NUSHmallows write-up[ctftime.org](https://ctftime.org/writeup/31843#:~:text=Since%20we%20are%20able%20to,of%20a%20unsort%20bin%20chunk)[ctftime.org](https://ctftime.org/writeup/31843#:~:text=,)|
|**heapme (Pwn)** – C++ heap vuln|FIC 2020 Prequals (2020)|Heap overflow + use-after-free in a C++ program. Achieved arbitrary **vtable pointer overwrite**. Leaked libc base via freed chunk in unsorted bin, then overwrote object’s vtable to point to a fake table (with pointer to `system` gadget)[synacktiv.com](https://www.synacktiv.com/en/publications/fic2020-prequals-ctf-write-up#:~:text=typedef%20struct%20vtable%20,write%29%28Disk%20this%29%3B%20%7D%20vtable)[synacktiv.com](https://www.synacktiv.com/en/publications/fic2020-prequals-ctf-write-up#:~:text=As%20we%20have%20a%20full,data%20part%20of%20the%20disk). Gained shell on virtual function call.|Synacktiv write-up[synacktiv.com](https://www.synacktiv.com/en/publications/fic2020-prequals-ctf-write-up#:~:text=typedef%20struct%20vtable%20,write%29%28Disk%20this%29%3B%20%7D%20vtable)[synacktiv.com](https://www.synacktiv.com/en/publications/fic2020-prequals-ctf-write-up#:~:text=As%20we%20have%20a%20full,data%20part%20of%20the%20disk)|
|**S2: Escape from Google Sandbox (Pwn)** – seccomp|Google CTF Quals (2022)|**Seccomp-bypass sandbox escape.** Only fork, seccomp, ioctl allowed. Used seccomp **USER_NOTIF** to create a supervisor that intercepts syscalls, bypassing Google’s ptrace-based monitor[n132.github.io](https://n132.github.io/2022/07/04/S2.html#:~:text=1,fd%29%20to%20allow%20all%20syscalls)[n132.github.io](https://n132.github.io/2022/07/04/S2.html#:~:text=,being%20traced%20by%20the%20monitor). Essentially tricked the sandbox into permitting all syscalls, then invoked execve.|n132’s blog[n132.github.io](https://n132.github.io/2022/07/04/S2.html#:~:text=1,fd%29%20to%20allow%20all%20syscalls)[n132.github.io](https://n132.github.io/2022/07/04/S2.html#:~:text=,being%20traced%20by%20the%20monitor)|
|**Nightmare (Pwn)** – loader abuse|(2022, custom challenge)|One-byte buffer overflow under strict seccomp (no network or normal syscalls). Exploit chained multiple primitives: manipulated the runtime loader (`ld.so`) by flipping a single byte to make `_Exit` return (an “impossible” condition)[blog.pepsipu.com](https://blog.pepsipu.com/posts/nightmare#:~:text=fine%20since%20,returns), thus looping a constructor function to gain unlimited writes. Ultimately built a full exploit chain blind (no leaks) by targeting loader and `IO` structures[blog.pepsipu.com](https://blog.pepsipu.com/posts/nightmare#:~:text=Go%20from%20one%20byte%20out,knowing%20ASLR%20base)[blog.pepsipu.com](https://blog.pepsipu.com/posts/nightmare#:~:text=The%20solution%20to%20nightmare%20introduces,relative%20space).|pepsi’s blog[blog.pepsipu.com](https://blog.pepsipu.com/posts/nightmare#:~:text=Go%20from%20one%20byte%20out,knowing%20ASLR%20base)[blog.pepsipu.com](https://blog.pepsipu.com/posts/nightmare#:~:text=fine%20since%20,returns)|
|**klibrary (Kernel Pwn)** – Linux kernel|3kCTF (2021)|Linux kernel use-after-free on a `tty_struct`. Overwrote a `tty->ops` function pointer (vtable) to pivot execution. By pointing the function to code that writes to the global `modprobe_path`, then triggering a modprobe, gained root (classic modprobe_path privilege escalation)[github.com](https://github.com/smallkirby/kernelpwn#:~:text=). Had to bypass KASLR via info leak and avoid SMEP (used ROP to mapped user shellcode).|smallkirby write-up[github.com](https://github.com/smallkirby/kernelpwn#:~:text=)[github.com](https://github.com/smallkirby/kernelpwn#:~:text=,80)|

_(Note: Each challenge name links to an original write-up or repository with full details. The “main trick” listed is a high-level summary – most challenges required combining multiple techniques, but we highlight the most distinctive aspect here.)_

## C. Suggested Practice Pathway (Ascending Difficulty)

To build proficiency, it’s useful to tackle challenges in increasing order of complexity. Below we suggest two parallel pathways – one for reverse-engineering and one for binary exploitation – each moving from introductory techniques to highly advanced ones. This allows you to develop each skillset systematically:

### Reversing Path (Easy → Hard)

1. **Basic Crackmes & Format Challenges:** Start with simple reverse challenges from beginner CTFs (e.g. picoCTF, TJCTF). These often involve hard-coded password checks or basic encoding. The goal is to get comfortable reading assembly or decompiled C. Example: _“keygenme” or “crackme0” (picoCTF 2019)_ – simple XOR or comparison against a constant. These teach you to use Ghidra/IDA, find the check routine, and perhaps use a debugger to bypass it. (_Reason:_ Builds fundamental static analysis skills without obfuscation.)
    
2. **Intermediate Obfuscation – Opaque Predicates:** Next, tackle a challenge with mild anti-reverse engineering. _LicenseCheck (EasyCTF 2018)_ is a great example, featuring opaque predicates and junk code (always-false jumps, anti-debug traps)[ctftime.org](https://ctftime.org/writeup/8782#:~:text=Write,jmp_loc%3B%20jmp%20eax%3B%20%C2%B7%20antidebug). Another is _reee (PlaidCTF 2020)_, which adds a runtime code decryption step and bogus jumps[medium.com](https://medium.com/the-bkpt/plaidctf-2020-reee-80c5cc21ccb1#:~:text=2,with%20opaque%20predicates%20like). Working through these will teach you how to spot and ignore obfuscation: you’ll practice patching binaries (to remove anti-debug checks or infinite loops) and use dynamic analysis (e.g. dumping decrypted code from memory). (_Reason:_ Introduces common obfuscation tricks in a manageable scenario.)
    
3. **Symbolic Execution Automation:** Once you can handle manual reversing, try integrating automation. A good mid-level challenge here is _angr-management (HackTM 2019)_ or any CTF task where you must solve a path constraint. If not available, revisit a previous crackme and solve it with angr. For instance, _DGST (Google CTF 2020)_ involved a path-dependent hash that was easiest solved by symbolic execution. By using angr on such tasks, you’ll learn to formulate problems for the solver, handle angr’s quirks, and combine concrete runs with symbolic states. (_Reason:_ Develops a toolkit mindset – knowing when to apply symbolic tools vs manual reversing.)
    
4. **Unknown Architecture or VM-based Challenge:** For a bigger step up, attempt a challenge where the architecture is unfamiliar or custom. A prime example is _0CTF 2022’s Vectrex ROM_ or a Harvard Architecture VM from a DEFCON Quals challenge. Solving these will likely involve writing or modifying an emulator, using a debugger on a foreign architecture, or scripting a disassembler. **Practice idea:** Take a GameBoy ROM CTF challenge or an ARM Thumb crackme if you’re only used to x86-64. Working through the initial confusion of a new ISA (instruction set architecture) vastly improves your general reversing skills. (_Reason:_ Teaches you to extract architecture specs and use emulation – a must for tackling modern mixed-binary or VM challenges.)
    
5. **Highly Obfuscated Binaries:** Finally, challenge yourself with fully obfuscated, high-difficulty reversals from CTF finals or competitions like Flare-On. Examples include _“J” (0CTF/TCTF 2020)_[hxp.io](https://hxp.io/blog/74/0CTF-2020-writeups/#:~:text=To%20worsen%20things%2C%20the%20authors,manual%20procedure%20during%20the%20second), which combined multiple obfuscation layers, or a challenge with heavy control-flow flattening and anti-emulation tricks (some DEF CON finals challenges fall here). These often require custom deobfuscation scripts, deep understanding of compiler optimizations, and a lot of patience. By the time you attempt this, you’ll be using all your accumulated skills: dynamic tracing, writing IDA/Ghidra Python scripts to assist, recognizing encryption or compression algorithms, etc. (_Reason:_ Represents the capstone of reversing – if you can handle this, you’re ready for any real-world binary analysis task.)
    

### Pwn (Exploitation) Path (Easy → Hard)

1. **Intro to Memory Corruption – Basics:** Start with simple stack overflows and format strings in controlled environments. For example, _picoCTF 2018 “buffer overflow 1”_ (classic ret2win) or _ROP Emporium challenges_. These teach fundamental concepts: overflowing a buffer to overwrite EIP/RIP, and using tools like GDB and Pwntools to craft payloads. Progress to a basic format-string exploit (e.g., _printf challenge from Angstrom CTF_) to learn how to read/write arbitrary memory via `%n`. (_Reason:_ Establishes the core exploit patterns and use of debugging/exploit scripting tools.)
    
2. **Return-Oriented Programming & Leaking Addresses:** Next, take on a challenge that requires constructing a ROP chain and leaking memory addresses. _BabyROP (DiceCTF 2021)_ is perfect: it’s a tiny binary where you practice using gadgets to call functions, and optionally use **ret2csu** and **ret2dlresolve** to call `system`[danielepusceddu.github.io](https://danielepusceddu.github.io/ctf_writeups/dice21_babyrop/#:~:text=This%20technique%20is%20extremely%20powerful,entry%20in%20the%20.plt). If that specific challenge isn’t available, any “ROP chain” exercise (like _ROPChats_ from HTB or _SploitFun’s tutorials_) will do. Here you’ll learn to use Pwntools’ ROP gadget finder, how to compute offsets for payloads, and how to perform a **Partial RELRO GOT overwrite** or ret2libc. (_Reason:_ Builds skill in controlling execution flow and using info leaks, which are prerequisites for most modern pwns.)
    
3. **Heap Exploitation (tcache and fastbin):** Once comfortable with stack-based exploits, move to the heap. A good intermediate challenge is _House of Atropos (pwn.college)_ or **Febroary** (_Angstrom CTF 2020_), which involve using tcache dup or poison techniques. _Coffee Shop (idekCTF 2021)_ is also instructive: a use-after-free that leads to tcache poisoning and function pointer hijack[ctftime.org](https://ctftime.org/writeup/31843#:~:text=Since%20we%20are%20able%20to,of%20a%20unsort%20bin%20chunk)[ctftime.org](https://ctftime.org/writeup/31843#:~:text=,). Through these, you’ll practice heap feng shui – allocating/freeing chunks to get a favorable layout – and learn glibc internals (tcache freelist, unsorted bin leaking). Tools like **libc-debug** and **heapviz** (for visualizing heap) can be enlightening. (_Reason:_ Mastering heap patterns greatly expands the range of vulnerabilities you can exploit beyond basic stack smashing.)
    
4. **Sandbox Escape / Advanced Environment:** Now tackle a challenge that adds constraints like seccomp or custom OS environments. _Systemd-rlimit (Google CTF 2020)_ or _S2 (Google CTF 2022)_ are great candidates – these restrict syscalls and force you to use one syscall to trick another (e.g., use `clone` or `seccomp` itself as in S2[n132.github.io](https://n132.github.io/2022/07/04/S2.html#:~:text=1,fd%29%20to%20allow%20all%20syscalls)). Alternatively, a challenge that runs your exploit in a Docker container with limited syscalls or with a seccomp filter (some xCTF finals do this). By solving such a challenge, you learn to read seccomp BPF filters (using `seccomp-tools`), find creative gadgets (like calling `syscall` instruction with registers set to an allowed syscall), or abuse unexpected mechanics (like invoking 32-bit syscalls on 64-bit filters[n132.github.io](https://n132.github.io/2022/07/03/Guide-of-Seccomp-in-CTF.html#:~:text=If%20the%20filter%20doesn%E2%80%99t%20check,ABI%20to%20bypass%20the%20filter)). (_Reason:_ Prepares you for real-world scenarios where exploits run in sandboxes and need escape techniques.)
    
5. **Kernel Pwn & Specialized Targets:** Finally, attempt a full kernel exploitation challenge or a very hardened userland pwn. For kernel, _HackySim (DEF CON CTF 2019)_ or _Fire of Salvation (CoRCTF 2021)_ are renowned – they require understanding kernel structures (e.g., `msg_msg` or `user_key_payload`)[github.com](https://github.com/smallkirby/kernelpwn#:~:text=,nightclub%20from%20pbctf%202021) and often chaining multiple bugs (info leak + UAF + privilege escalation). If kernel is too steep, an advanced userland challenge like _Nightmare (2022)_[blog.pepsipu.com](https://blog.pepsipu.com/posts/nightmare#:~:text=Go%20from%20one%20byte%20out,knowing%20ASLR%20base) or _Seccomp Hell (HITCON 2024)_ will test similar skills – dealing with restricted environments, blind exploitation (no direct output or known addresses), and sometimes with just a one-shot vulnerability that demands creative use. At this level, you’ll likely script custom heap groomers, use dynamic analysis tools (e.g., Intel PIN or DynamoRIO) to watch memory, and possibly employ symbolic execution to reason about exploitability. (_Reason:_ This is the peak of CTF pwn; succeeding here means you can handle complex, real-world exploit development tasks with confidence.)
    

Each step of these pathways builds on the previous, reinforcing techniques and introducing new ones. By the end, you’ll have a broad arsenal of approaches – from reversing obfuscated code under a debugger to crafting kernel ROP chains – and the experience to quickly recognize which techniques apply to new challenges. Good luck and happy hacking!

![](assets/Pasted%20image%2020251102120310.png)